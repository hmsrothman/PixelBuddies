import static org.lwjgl.opengl.GL.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL13.*;
import static org.lwjgl.opengl.GL20.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.opengl.GL31.*;
import static org.lwjgl.opengl.GL32.*;
import static org.lwjgl.opengl.GL33.*;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;





public class GLSLProgram {
	private int programID, 
				 vertexShaderID,
				 fragmentShaderID;
	
	public void compileShaders(String vertexPath, String fragmentPath){
		if((vertexShaderID = glCreateShader(GL_VERTEX_SHADER))==0){
			System.err.println("Vertex Shader Allocation Failure");
		};
		
		if((fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER))==0){
			System.err.println("Fragment Shader Allocation Failure");
		};
		
		compileShader(vertexPath, vertexShaderID);
		compileShader(fragmentPath, fragmentShaderID);
	}
	
	private  void compileShader(String path, int id){
		StringBuilder result = new StringBuilder();
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new FileReader(path));
			String buffer = "";
			while ((buffer = reader.readLine()) != null) {
				result.append(buffer);
				result.append("\n");
			}

		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void destroy(){
		glDeleteProgram(programID);
		glDeleteShader(vertexShaderID);
		glDeleteShader(fragmentShaderID);
	}

}
